// Code generated by hertz generator.

package aliyun

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/cloudisk/biz/dal/query"
	aliyun "github.com/cloudisk/biz/model/aliyun"
	"github.com/cloudisk/biz/service"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

// Upload .
// @router /api/file/content/upload [POST]
func Upload(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.UploadReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	user, _ := service.GetUserInfo(c.GetHeader("Token"))
	form, err := c.MultipartForm()
	if err != nil {
		return
	}
	file := form.File["files"][0]
	pid, _ := strconv.Atoi(req.GetPid())
	cover, _ := strconv.ParseBool(req.GetCover())
	webkitRelativePath := req.GetWebkitRelativePath()

	log.Printf("开始上传文件: %s", file.Filename)

	item, err := service.Upload(user, pid, webkitRelativePath, cover, *file)
	if err != nil {
		log.Printf("文件上传失败: %s, 错误: %v", file.Filename, err)
		resp := new(aliyun.UploadResp)
		resp.Ret = 0
		resp.Msg = "文件上传失败: " + err.Error()
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	log.Printf("文件上传成功: %s", file.Filename)

	resp := new(aliyun.UploadResp)
	resp.Data = append(resp.Data, item)
	resp.Ret = 1
	resp.Msg = file.Filename + " 上传成功"

	c.JSON(consts.StatusOK, resp)
}

// OfficeUpload .
// @router /api/file/content/office [GET、POST]
func OfficeUpload(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.OfficeUploadReq

	fileId := c.Query("id")
	if id, err := strconv.Atoi(fileId); err == nil {
		req.Id = int32(id)
	}
	if len(c.Request.Body()) > 0 {
		if err = c.BindAndValidate(&req); err != nil {
			c.String(consts.StatusBadRequest, err.Error())
			return
		}
	}
	user, _ := service.GetUserInfo(c.GetHeader("Token"))

	switch req.GetStatus() {
	case 2: // 文档已保存
		err = service.OfficeUpload(user, int(req.GetId()), int(req.GetStatus()),
			req.GetKey(), req.GetUrl())
		if err != nil {
			c.String(consts.StatusBadRequest, err.Error())
			return
		}
	}

	resp := new(aliyun.OfficeUploadResp)
	resp.Error = 0
	c.JSON(consts.StatusOK, resp)
}

// Save .
// @router /api/file/content/save [POST]
func Save(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.SaveReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(aliyun.SaveResp)

	c.JSON(consts.StatusOK, resp)
}

// Download .
// @router /api/file/content/download [GET]
func Download(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.DownloadReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	fileID := req.FileId

	// 查询最新的文件内容记录
	fileContent, _ := query.Q.FileContent.
		Where(query.FileContent.Fid.Eq(int64(fileID))).
		Order(query.FileContent.UpdatedAt.Desc()).
		First()

	// 解析content字段获取cloud_url
	var content map[string]interface{}
	_ = json.Unmarshal([]byte(fileContent.Content), &content)

	cloudURL, _ := content["cloud_url"].(string)

	// 获取文件基本信息
	file, _ := query.Q.File.
		Where(query.File.ID.Eq(int64(fileID))).
		First()

	// 获取本地下载目录
	localDir := os.Getenv("LOCAL_DOWNLOAD_DIR")
	if localDir == "" {
		log.Printf("本地保存目录未配置")
		resp := new(aliyun.DownloadResp)
		resp.Ret = 0
		resp.Msg = "系统配置错误: 本地保存目录未配置"
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	// 构造本地文件路径
	localFileName := fmt.Sprintf("%d_%s.%s", fileID, file.Name, file.Ext)
	localFilePath := filepath.Join(localDir, localFileName)

	// 下载文件
	err = service.DownloadFileFromURL(cloudURL, localFilePath)
	if err != nil {
		log.Printf("下载文件失败: %s, 错误: %v", cloudURL, err)
		resp := new(aliyun.DownloadResp)
		resp.Ret = 0
		resp.Msg = "保存文件失败: " + err.Error()
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	// 更新数据库中的本地文件路径
	err = service.UpdateFileContentURLInDB(int64(fileID), localFilePath)
	if err != nil {
		log.Printf("更新文件URL失败, ID: %d, 错误: %v", fileID, err)
		resp := new(aliyun.DownloadResp)
		resp.Ret = 0
		resp.Msg = "更新文件信息失败: " + err.Error()
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	log.Printf("文件保存成功: %s, ID: %d", localFileName, fileID)

	resp := new(aliyun.DownloadResp)
	resp.Ret = 1
	resp.Msg = "保存成功"

	c.JSON(consts.StatusOK, resp)
}

// Remove .
// @router /api/file/content/remove [DELETE]
func Remove(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.RemoveReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	user, _ := service.GetUserInfo(c.GetHeader("Token"))
	fileID := req.FileId
	log.Printf("开始删除本地文件, ID: %d", fileID)

	err = service.DeleteLocalFileWithUser(user, fileID)
	if err != nil {
		log.Printf("删除文件失败, ID: %d, 错误: %v", fileID, err)
		resp := new(aliyun.RemoveResp)
		resp.Ret = 0
		resp.Msg = "删除失败: " + err.Error()
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	log.Printf("本地文件删除成功, ID: %d", fileID)

	resp := new(aliyun.RemoveResp)
	resp.Ret = 1
	resp.Msg = "删除成功"

	c.JSON(consts.StatusOK, resp)
}

// Downloading .
// @router /api/file/content/downloading [GET]
func Downloading(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.DownloadReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	fileID := req.FileId
	file, err := query.Q.File.Where(query.File.ID.Eq(int64(fileID))).First()
	if err != nil {
		c.String(consts.StatusBadRequest, "文件不存在")
		return
	}

	// 递归获取完整的文件夹路径
	paths := []string{}
	currentFile := file

	// 递归向上查找父文件夹
	for currentFile.Pid > 0 {
		parentFile, err := query.Q.File.Where(query.File.ID.Eq(currentFile.Pid)).First()
		if err != nil {
			log.Printf("获取父文件夹信息失败, ID: %d, 错误: %v", currentFile.Pid, err)
			break
		}
		
		if parentFile.Type == "folder" {
			log.Printf("添加文件夹到路径: %s (ID: %d)", parentFile.Name, parentFile.ID)
			// 将新的文件夹名添加到路径开头
			paths = append([]string{parentFile.Name}, paths...)
		}
		
		currentFile = parentFile
	}

	// 构建完整的文件路径
	fileName := file.Name
	if file.Ext != "" {
		fileName = fileName + "." + file.Ext
	}
	fullPath := fileName
	if len(paths) > 0 {
		fullPath = strings.Join(paths, "/") + "/" + fileName
		log.Printf("构建的完整文件路径: %s", fullPath)
	}

	log.Printf("开始下载文件: %s, ID: %d", fullPath, fileID)

	fileData, err := service.DownloadFile(fullPath)
	if err != nil {
		log.Printf("下载文件失败: %s, 错误: %v", fullPath, err)
		c.String(consts.StatusInternalServerError, "下载文件失败: "+err.Error())
		return
	}

	log.Printf("文件下载成功: %s, ID: %d", fullPath, fileID)

	c.Header("Content-Disposition", "attachment; filename="+fileName)
	c.Header("Content-Type", "application/octet-stream")
	c.Data(consts.StatusOK, "application/octet-stream", fileData)
}

// IoUpload .
// @router /api/file/content/io_upload [POST]
func IoUpload(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.IoUploadReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	user, _ := service.GetUserInfo(c.GetHeader("Token"))
	fileID := req.GetFileId()
	file, err := query.Q.File.Where(query.File.ID.Eq(int64(fileID))).First()
	if err != nil {
		c.String(consts.StatusBadRequest, "文件不存在")
		return
	}

	filePath, err := service.GetFileContentURL(int64(fileID))
	if err != nil {
		c.String(consts.StatusBadRequest, "获取文件路径失败")
		return
	}

	fileReader, err := os.Open(filePath)
	if err != nil {
		c.String(consts.StatusBadRequest, "打开文件失败")
		return
	}
	defer fileReader.Close()

	cover, _ := strconv.ParseBool(req.GetCover())
	webkitRelativePath := req.GetWebkitRelativePath()

	resp := new(aliyun.IoUploadResp)
	fileName := file.Name + "." + file.Ext

	// 添加上传前的日志
	log.Printf("开始上传文件: %s, 文件ID: %d", fileName, fileID)

	// 使用 fileID 而不是 pid
	item, err := service.Io_Upload(user, int(fileID), webkitRelativePath, cover, fileReader, fileName)
	if err != nil {
		log.Printf("文件上传失败: %s, 错误: %v", fileName, err)
		resp.Ret = 0
		resp.Msg = "文件上传失败: " + err.Error()
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	// 添加上传成功的日志
	log.Printf("文件上传成功: %s, 文件ID: %d", fileName, fileID)

	resp.Data = append(resp.Data, item)
	resp.Ret = 1
	resp.Msg = fileName + " 上传成功"

	c.JSON(consts.StatusOK, resp)
}

// DownloadingOffice .
// @router /api/file/content/downloading_office [GET]
func DownloadingOffice(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.DownloadOfficeReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	ossFileName := req.Key
	log.Printf("开始下载文件: %s", ossFileName)

	fileData, err := service.DownloadFile(ossFileName)
	if err != nil {
		log.Printf("下载文件失败: %s, 错误: %v", ossFileName, err)
		c.String(consts.StatusInternalServerError, "下载文件失败: "+err.Error())
		return
	}

	log.Printf("文件下载成功: %s", ossFileName)

	c.Header("Content-Disposition", "attachment; filename="+ossFileName)
	c.Header("Content-Type", "application/octet-stream")
	c.Data(consts.StatusOK, "application/octet-stream", fileData)
}

// Status .
// @router /api/file/content/status [GET]
func Status(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.StatusReq
	err = c.BindAndValidate(&req)
	if err != nil {
		log.Printf("Bind and validate error: %v", err)
		resp := new(aliyun.StatusResp)
		resp.Ret = 1
		resp.Msg = "success"
		resp.Data = make([]*aliyun.FileStatus, 0)
		c.JSON(consts.StatusOK, resp)
		return
	}

	resp := new(aliyun.StatusResp)
	resp.Ret = 1
	resp.Msg = "success"
	resp.Data = make([]*aliyun.FileStatus, 0)

	// 获取文件内容
	log.Printf("开始查询文件状态: %v", req.FileIds)
	fileContents, err := query.Q.FileContent.
		Where(query.FileContent.Fid.In(service.SliceInt32ToInt64(req.FileIds)...)).
		Order(query.FileContent.UpdatedAt.Desc()).
		Find()
	if err != nil {
		log.Printf("Query error: %v", err)
		c.JSON(consts.StatusOK, resp)
		return
	}

	// 处理每个文件的内容
	processedIDs := make(map[int32]bool)
	for _, fileContent := range fileContents {
		fileID := int32(fileContent.Fid)
		// 如果已经处理过这个ID，跳过
		if processedIDs[fileID] {
			continue
		}
		processedIDs[fileID] = true

		fileStatus := &aliyun.FileStatus{
			ID:     fileID,
			Status: "none", // 默认状态
		}

		var contentMap map[string]interface{}
		if err := json.Unmarshal([]byte(fileContent.Content), &contentMap); err != nil {
			log.Printf("JSON unmarshal error for FileId %d: %v", fileStatus.ID, err)
			resp.Data = append(resp.Data, fileStatus)
			continue
		}

		// 检查cloud_url字段
		if cloudURL, hasCloudURL := contentMap["cloud_url"].(string); hasCloudURL && cloudURL != "" {
			fileStatus.Status = "cloud"

			// 检查url字段
			if url, hasURL := contentMap["url"].(string); hasURL {
				url = strings.ReplaceAll(url, "\\/", "/")
				if url != "" {
					fileStatus.Status = "cloud_confirmed"
				}
			}
		}

		resp.Data = append(resp.Data, fileStatus)
	}

	log.Printf("查询文件状态完成: %+v", resp)
	c.JSON(consts.StatusOK, resp)
}
