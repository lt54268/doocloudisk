// Code generated by hertz generator.

package aliyun

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strconv"

	"github.com/cloudisk/biz/dal/query"
	aliyun "github.com/cloudisk/biz/model/aliyun"
	"github.com/cloudisk/biz/service"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

// Upload .
// @router /api/file/content/upload [POST]
func Upload(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.UploadReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	user, _ := service.GetUserInfo(c.GetHeader("Token"))
	form, err := c.MultipartForm()
	if err != nil {
		return
	}
	file := form.File["files"][0]
	pid, _ := strconv.Atoi(req.GetPid())
	cover, _ := strconv.ParseBool(req.GetCover())
	webkitRelativePath := req.GetWebkitRelativePath()

	log.Printf("开始上传文件: %s", file.Filename)

	item, err := service.Upload(user, pid, webkitRelativePath, cover, *file)
	if err != nil {
		log.Printf("文件上传失败: %s, 错误: %v", file.Filename, err)
		resp := new(aliyun.UploadResp)
		resp.Ret = 0
		resp.Msg = "文件上传失败: " + err.Error()
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	log.Printf("文件上传成功: %s", file.Filename)

	resp := new(aliyun.UploadResp)
	resp.Data = append(resp.Data, item)
	resp.Ret = 1
	resp.Msg = file.Filename + " 上传成功"

	c.JSON(consts.StatusOK, resp)
}

// OfficeUpload .
// @router /api/file/content/office [GET、POST]
func OfficeUpload(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.OfficeUploadReq

	fileId := c.Query("id")
	if id, err := strconv.Atoi(fileId); err == nil {
		req.Id = int32(id)
	}
	if len(c.Request.Body()) > 0 {
		if err = c.BindAndValidate(&req); err != nil {
			c.String(consts.StatusBadRequest, err.Error())
			return
		}
	}
	user, _ := service.GetUserInfo(c.GetHeader("Token"))

	switch req.GetStatus() {
	case 2: // 文档已保存
		err = service.OfficeUpload(user, int(req.GetId()), int(req.GetStatus()),
			req.GetKey(), req.GetUrl())
		if err != nil {
			c.String(consts.StatusBadRequest, err.Error())
			return
		}
	}

	resp := new(aliyun.OfficeUploadResp)
	resp.Error = 0
	c.JSON(consts.StatusOK, resp)
}

// Save .
// @router /api/file/content/save [POST]
func Save(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.SaveReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(aliyun.SaveResp)

	c.JSON(consts.StatusOK, resp)
}

// Download .
// @router /api/file/content/download [GET]
func Download(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.DownloadReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	fileID := req.FileId

	// 查询最新的文件内容记录
	fileContent, _ := query.Q.FileContent.
		Where(query.FileContent.Fid.Eq(int64(fileID))).
		Order(query.FileContent.UpdatedAt.Desc()).
		First()

	// 解析content字段获取cloud_url
	var content map[string]interface{}
	_ = json.Unmarshal([]byte(fileContent.Content), &content)

	cloudURL, _ := content["cloud_url"].(string)

	// 获取文件基本信息
	file, _ := query.Q.File.
		Where(query.File.ID.Eq(int64(fileID))).
		First()

	// 获取本地下载目录
	localDir := os.Getenv("LOCAL_DOWNLOAD_DIR")
	if localDir == "" {
		log.Printf("本地保存目录未配置")
		resp := new(aliyun.DownloadResp)
		resp.Ret = 0
		resp.Msg = "系统配置错误: 本地保存目录未配置"
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	// 构造本地文件路径
	localFileName := fmt.Sprintf("%d_%s.%s", fileID, file.Name, file.Ext)
	localFilePath := filepath.Join(localDir, localFileName)

	// 下载文件
	err = service.DownloadFileFromURL(cloudURL, localFilePath)
	if err != nil {
		log.Printf("下载文件失败: %s, 错误: %v", cloudURL, err)
		resp := new(aliyun.DownloadResp)
		resp.Ret = 0
		resp.Msg = "保存文件失败: " + err.Error()
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	// 更新数据库中的本地文件路径
	err = service.UpdateFileContentURLInDB(int64(fileID), localFilePath)
	if err != nil {
		log.Printf("更新文件URL失败, ID: %d, 错误: %v", fileID, err)
		resp := new(aliyun.DownloadResp)
		resp.Ret = 0
		resp.Msg = "更新文件信息失败: " + err.Error()
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	log.Printf("文件保存成功: %s, ID: %d", localFileName, fileID)

	resp := new(aliyun.DownloadResp)
	resp.Ret = 1
	resp.Msg = "保存成功"

	c.JSON(consts.StatusOK, resp)
}

// Remove .
// @router /api/file/content/remove [DELETE]
func Remove(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.RemoveReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	user, _ := service.GetUserInfo(c.GetHeader("Token"))
	fileID := req.FileId
	log.Printf("开始删除本地文件, ID: %d", fileID)

	err = service.DeleteLocalFileWithUser(user, fileID)
	if err != nil {
		log.Printf("删除文件失败, ID: %d, 错误: %v", fileID, err)
		resp := new(aliyun.RemoveResp)
		resp.Ret = 0
		resp.Msg = "删除失败: " + err.Error()
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	log.Printf("本地文件删除成功, ID: %d", fileID)

	resp := new(aliyun.RemoveResp)
	resp.Ret = 1
	resp.Msg = "删除成功"

	c.JSON(consts.StatusOK, resp)
}

// Downloading .
// @router /api/file/content/downloading [GET]
func Downloading(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.DownloadReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	fileID := req.FileId
	file, _ := query.Q.File.Where(query.File.ID.Eq(int64(fileID))).First()
	ossFileName := file.Name + "." + file.Ext
	log.Printf("开始下载文件: %s, ID: %d", ossFileName, fileID)

	fileData, err := service.DownloadFile(ossFileName)
	if err != nil {
		log.Printf("下载文件失败: %s, 错误: %v", ossFileName, err)
		c.String(consts.StatusInternalServerError, "下载文件失败: "+err.Error())
		return
	}

	log.Printf("文件下载成功: %s, ID: %d", ossFileName, fileID)

	c.Header("Content-Disposition", "attachment; filename="+ossFileName)
	c.Header("Content-Type", "application/octet-stream")
	c.Data(consts.StatusOK, "application/octet-stream", fileData)
}

// IoUpload .
// @router /api/file/content/io_upload [POST]
func IoUpload(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.IoUploadReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	user, _ := service.GetUserInfo(c.GetHeader("Token"))
	fileID := req.GetFileId()
	file, _ := query.Q.File.Where(query.File.ID.Eq(int64(fileID))).First()
	filePath, _ := service.GetFileContentURL(int64(fileID))
	fileReader, _ := os.Open(filePath)
	defer fileReader.Close()
	pid, _ := strconv.Atoi(req.GetPid())
	cover, _ := strconv.ParseBool(req.GetCover())
	webkitRelativePath := req.GetWebkitRelativePath()

	resp := new(aliyun.IoUploadResp)
	fileName := file.Name + "." + file.Ext

	// 添加上传前的日志
	log.Printf("开始上传文件: %s, 文件ID: %d", fileName, fileID)

	item, err := service.Io_Upload(user, pid, webkitRelativePath, cover, fileReader, fileName)
	if err != nil {
		log.Printf("文件上传失败: %s, 错误: %v", fileName, err)
		resp.Ret = 0
		resp.Msg = "文件上传失败: " + err.Error()
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	// 添加上传成功的日志
	log.Printf("文件上传成功: %s, 文件ID: %d", fileName, fileID)

	resp.Data = append(resp.Data, item)
	resp.Ret = 1
	resp.Msg = fileName + " 上传成功"

	c.JSON(consts.StatusOK, resp)
}

// DownloadingOffice .
// @router /api/file/content/downloading_office [GET]
func DownloadingOffice(ctx context.Context, c *app.RequestContext) {
	var err error
	var req aliyun.DownloadOfficeReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	ossFileName := req.Key
	log.Printf("开始下载文件: %s", ossFileName)

	fileData, err := service.DownloadFile(ossFileName)
	if err != nil {
		log.Printf("下载文件失败: %s, 错误: %v", ossFileName, err)
		c.String(consts.StatusInternalServerError, "下载文件失败: "+err.Error())
		return
	}

	log.Printf("文件下载成功: %s", ossFileName)

	c.Header("Content-Disposition", "attachment; filename="+ossFileName)
	c.Header("Content-Type", "application/octet-stream")
	c.Data(consts.StatusOK, "application/octet-stream", fileData)
}
